 
import { test, expect, type Page, TestInfo } from '@playwright/test';
import AxeBuilder from '@axe-core/playwright';
import type { Result as AxeResult, NodeResult } from 'axe-core';
import * as fs from 'fs';
import * as path from 'path';

/**
 * Accessibility E2E Tests for Vinto Card Game
 *
 * This test suite uses axe-core to automatically scan for accessibility violations,
 * with a strong focus on color contrast and WCAG compliance.
 *
 * Tests are performed on both light and dark themes to ensure accessibility
 * across all color schemes.
 *
 * If violations are found, the test fails and generates a detailed accessibility-report.md file.
 */

const THEME_TRANSITION_TIMEOUT = 5000;

// Suite-level violation tracking
interface ViolationRecord {
  theme: string;
  testName: string;
  url: string;
  violations: AxeResult[];
}

const suiteViolations: Map<string, ViolationRecord[]> = new Map();

test.describe('Accessibility Tests', () => {
  // Ensure accessibility-reports directory exists before any tests run
  test.beforeAll(() => {
    const reportDir = path.join(process.cwd(),'..', '..', 'accessibility-reports');
  console.log(`Attempting to create directory at: ${reportDir}`);

  if (!fs.existsSync(reportDir)) {
    fs.mkdirSync(reportDir, { recursive: true });
    console.log(`Directory created successfully at: ${reportDir}`);
  } else {
    console.log(`Directory already exists at: ${reportDir}`);
  }

    // Create README to ensure directory is never empty (for artifact upload)
    const readmePath = path.join(reportDir, 'README.md');
    if (!fs.existsSync(readmePath)) {
      fs.writeFileSync(
        readmePath,
        '# Accessibility Reports\n\n' +
          'This directory contains accessibility test reports generated by Playwright.\n\n' +
          'If this is the only file here, no accessibility violations were found!\n',
        'utf-8'
      );
    }
  });

  test.describe('Homepage Accessibility', () => {
    const suiteName = 'Homepage Accessibility';

    (['light', 'dark'] as const).forEach((theme) => {
      test(`should not have accessibility violations on homepage (${theme} theme)`, async ({
        page,
      }) => {
        // Navigate to the page
        await page.goto('/');
        await page.waitForLoadState('domcontentloaded');

        // Set theme
        await setTheme(page, theme);

        // Run accessibility scan and collect violations
        await collectAccessibilityViolations(
          page,
          theme,
          'Homepage',
          suiteName
        );
      });
    });

    test.afterAll(async ({}, testInfo) => {
      // Generate consolidated report for this suite
      await generateConsolidatedReport(suiteName, testInfo);
    });
  });

  test.describe('Color Contrast Validation', () => {
    test('should detect color contrast violations when present', async ({
      page,
    }) => {
      // Create a page with known bad contrast for validation
      await page.setContent(`
        <!DOCTYPE html>
        <html>
          <head>
            <title>Color Contrast Test</title>
          </head>
          <body>
            <button style="background-color: #888; color: #999; padding: 10px;">
              Low Contrast Button
            </button>
            <p style="color: #777; background-color: #888;">
              Low contrast text
            </p>
          </body>
        </html>
      `);

      // Run accessibility scan
      const accessibilityScanResults = await new AxeBuilder({
        page,
      }).analyze();

      // Expect violations to be found
      expect(accessibilityScanResults.violations.length).toBeGreaterThan(0);

      // Check that at least one violation is related to color contrast
      const contrastViolation = accessibilityScanResults.violations.find(
        (v) => v.id === 'color-contrast'
      );
      expect(contrastViolation).toBeDefined();
    });

    test('should pass with good color contrast', async ({ page }) => {
      // Create a page with good contrast
      await page.setContent(`
        <!DOCTYPE html>
        <html>
          <head>
            <title>Good Contrast Test</title>
          </head>
          <body>
            <button style="background-color: #000; color: #fff; padding: 10px;">
              Good Contrast Button
            </button>
            <p style="color: #000; background-color: #fff;">
              Good contrast text
            </p>
          </body>
        </html>
      `);

      // Run accessibility scan
      const accessibilityScanResults = await new AxeBuilder({
        page,
      }).analyze();

      // Should have no color contrast violations
      const contrastViolation = accessibilityScanResults.violations.find(
        (v) => v.id === 'color-contrast'
      );
      expect(contrastViolation).toBeUndefined();
    });
  });

  test.describe('Game Interface Accessibility', () => {
    const suiteName = 'Game Interface Accessibility';

    (['light', 'dark'] as const).forEach((theme) => {
      test(`should not have accessibility violations on game board (${theme} theme)`, async ({
        page,
      }) => {
        // Navigate to the page
        await page.goto('/');

        await setTheme(page, theme);

        // Wait for game board to be visible
        const gameBoard = page
          .locator('[data-testid="middle-area"]')
          .or(page.getByRole('main'));
        await expect(gameBoard).toBeVisible({ timeout: 15000 });

        // Run accessibility scan and collect violations
        await collectAccessibilityViolations(
          page,
          theme,
          'Game Board',
          suiteName
        );
      });
    });

    test.afterAll(async ({}, testInfo) => {
      // Generate consolidated report for this suite
      await generateConsolidatedReport(suiteName, testInfo);
    });
  });

  test.describe('Specific WCAG Rules', () => {
      test('should have valid ARIA attributes', async ({ page }) => {
        await page.goto('/');
        await page.waitForLoadState('domcontentloaded');

        const accessibilityScanResults = await new AxeBuilder({ page })
          .withTags(['wcag2a', 'wcag2aa'])
          .analyze();

        // Check for ARIA-related violations
        const ariaViolations = accessibilityScanResults.violations.filter((v) =>
          Boolean(v.id.includes('aria') || v.tags.includes('aria'))
        );

        expect(ariaViolations).toEqual([]);
      });

      test('should have proper heading hierarchy', async ({ page }) => {
        await page.goto('/');
        await page.waitForLoadState('domcontentloaded');

        const accessibilityScanResults = await new AxeBuilder({ page })
          .withTags(['wcag2a', 'wcag2aa'])
          .analyze();

        // Check for heading order violations
        const headingViolations = accessibilityScanResults.violations.filter(
          (v) => v.id === 'heading-order'
        );

        expect(headingViolations).toEqual([]);
      });

      test('should have accessible form controls', async ({ page }) => {
        await page.goto('/');
        await page.waitForLoadState('domcontentloaded');

        const accessibilityScanResults = await new AxeBuilder({ page })
          .withTags(['wcag2a', 'wcag2aa'])
          .analyze();

        // Check for form-related violations
        const formViolations = accessibilityScanResults.violations.filter((v) =>
          Boolean(v.id.includes('label') || v.id.includes('form'))
        );

        expect(formViolations).toEqual([]);
      });
    });
});

/**
 * Collects accessibility violations and fails the test if any are found.
 * Violations are stored for suite-level consolidated reporting in afterAll hooks.
 */
async function collectAccessibilityViolations(
  page: Page,
  theme: string,
  testName: string,
  suiteName: string
): Promise<void> {
  // Run accessibility scan with WCAG 2.1 AA standards
  const accessibilityScanResults = await new AxeBuilder({ page })
    .withTags(['wcag2a', 'wcag2aa', 'wcag21a', 'wcag21aa'])
    .disableRules(['meta-viewport'])
    .analyze();

  // Store violations for suite-level reporting (stored BEFORE test fails)
  if (!suiteViolations.has(suiteName)) {
    suiteViolations.set(suiteName, []);
  }

  suiteViolations.get(suiteName)!.push({
    theme,
    testName,
    url: page.url(),
    violations: accessibilityScanResults.violations,
  });

  // Log results
  if (accessibilityScanResults.violations.length > 0) {
    console.log(
      `‚ùå ${testName} (${theme} theme): ${accessibilityScanResults.violations.length} violation(s)`
    );
  } else {
    console.log(`‚úÖ ${testName} (${theme} theme): No violations`);
  }

  // Fail the test if violations found (violations already stored above)
  expect(accessibilityScanResults.violations).toEqual([]);
}

/**
 * Generates consolidated Jira-ready report for a suite
 */
async function generateConsolidatedReport(
  suiteName: string,
  testInfo: TestInfo
): Promise<void> {
  const records = suiteViolations.get(suiteName) || [];

  // Always generate a report, even if no violations (for transparency)
  const report = generateJiraReadyReport(suiteName, records);

  // Include browser/project name in filename to prevent overwrites across different browser runs
  const projectName = testInfo.project.name.toLowerCase().replace(/\s+/g, '-');
  const filename = `accessibility-report-${projectName}-${suiteName
    .toLowerCase()
    .replace(/\s+/g, '-')}.md`;

  // Attach to Playwright test results
  await testInfo.attach(filename, {
    body: report,
    contentType: 'text/markdown',
  });

  // Write to accessibility-reports directory (separate from playwright-report to avoid cleanup)
  const reportDir = path.join(process.cwd(),'..', '..', 'accessibility-reports');
  if (!fs.existsSync(reportDir)) {
    fs.mkdirSync(reportDir, { recursive: true });
  }
  fs.writeFileSync(path.join(reportDir, filename), report, 'utf-8');

  console.log(`Generated accessibility report: ${filename} (${records.length} test records, ${records.reduce((sum, r) => sum + r.violations.length, 0)} violations)`);

  // Don't clear violations here - they should persist across retries
  // This ensures that if a test fails with violations and then retries,
  // the report will still contain the violations from all attempts
}

/**
 * Generates Jira-ready tickets from accessibility violations
 */
function generateJiraReadyReport(
  suiteName: string,
  records: ViolationRecord[]
): string {
  let report = `# Accessibility Issues: ${suiteName}\n\n`;
  report += `**Generated**: ${new Date().toISOString()}\n\n`;

  // Calculate total violations
  const totalViolations = records.reduce(
    (sum, r) => sum + r.violations.length,
    0
  );

  if (totalViolations === 0) {
    report += `‚úÖ **No accessibility violations found!**\n`;
    return report;
  }

  report += `**Total Issues**: ${totalViolations}\n\n`;

  // Group all violations by ID across all themes
  const violationsByIdAndTheme = new Map<
    string,
    Map<string, { violation: AxeResult; record: ViolationRecord }[]>
  >();

  records.forEach((record) => {
    record.violations.forEach((violation) => {
      if (!violationsByIdAndTheme.has(violation.id)) {
        violationsByIdAndTheme.set(violation.id, new Map());
      }
      const themeMap = violationsByIdAndTheme.get(violation.id)!;

      if (!themeMap.has(record.theme)) {
        themeMap.set(record.theme, []);
      }
      themeMap.get(record.theme)!.push({ violation, record });
    });
  });

  // Generate Jira-ready tickets
  let ticketNumber = 1;

  violationsByIdAndTheme.forEach((themeMap, violationId) => {
    const firstViolation = Array.from(themeMap.values())[0][0].violation;
    const impactLevel = firstViolation.impact || 'unknown';
    const priority = getJiraPriority(impactLevel);

    report += `---\n\n`;
    report += `## Ticket ${ticketNumber}: ${firstViolation.help}\n\n`;

    // Ticket metadata
    report += `**Priority**: ${priority}\n`;
    report += `**Impact**: ${impactLevel.toUpperCase()}\n`;
    report += `**Rule ID**: \`${violationId}\`\n`;
    report += `**WCAG**: ${firstViolation.tags
      .filter((t) => t.startsWith('wcag'))
      .join(', ')}\n\n`;

    // Description
    report += `### Description\n\n`;
    report += `${firstViolation.description}\n\n`;

    // Affected themes
    report += `### Affected Themes\n\n`;
    themeMap.forEach((entries, theme) => {
      const totalElements = entries.reduce(
        (sum, e) => sum + e.violation.nodes.length,
        0
      );
      report += `- **${theme}**: ${totalElements} element(s) affected\n`;
    });
    report += `\n`;

    // Technical details per theme
    report += `### Technical Details\n\n`;
    themeMap.forEach((entries, theme) => {
      report += `<details>\n`;
      report += `<summary><strong>${theme} theme</strong> - ${entries[0].violation.nodes.length} affected elements</summary>\n\n`;

      entries[0].violation.nodes.forEach((node: NodeResult, idx: number) => {
        report += `#### Element ${idx + 1}\n\n`;
        report += `**Selector**: \`${node.target.join(' ')}\`\n\n`;
        report += `**HTML**:\n\`\`\`html\n${node.html}\n\`\`\`\n\n`;
        report += `**Issue**: ${node.failureSummary}\n\n`;

        if (node.any && node.any.length > 0) {
          report += `**Fix any of**:\n`;
          node.any.forEach((fix) => {
            report += `- ${fix.message}\n`;
          });
          report += `\n`;
        }

        if (node.all && node.all.length > 0) {
          report += `**Fix all of**:\n`;
          node.all.forEach((fix) => {
            report += `- ${fix.message}\n`;
          });
          report += `\n`;
        }
      });

      report += `</details>\n\n`;
    });

    // Acceptance criteria
    report += `### Acceptance Criteria\n\n`;
    report += `- [ ] All \`${violationId}\` violations are resolved\n`;
    report += `- [ ] Changes are verified in both light and dark themes\n`;
    report += `- [ ] Accessibility tests pass without violations\n`;
    report += `- [ ] Manual testing confirms proper functionality\n\n`;

    // Resources
    report += `### Resources\n\n`;
    report += `- [WCAG Documentation](${firstViolation.helpUrl})\n`;
    report += `- [Axe Rule: ${violationId}](${firstViolation.helpUrl})\n\n`;

    // Generate copyable issue text for GitHub
    const issueTitle = `[A11y] ${firstViolation.help}`;
    const issueBody = generateGitHubIssueBody(
      firstViolation,
      violationId,
      priority,
      impactLevel,
      themeMap,
      suiteName
    );
    const createIssueUrl = generateGitHubIssueUrl(issueTitle, issueBody);

    // Add copy-friendly format and create issue button
    report += `### üé´ Create GitHub Issue\n\n`;
    report += `[üìù Create Issue on GitHub](${createIssueUrl})\n\n`;
    report += `<details>\n`;
    report += `<summary>üìã <strong>Copy-friendly issue template</strong> (click to expand)</summary>\n\n`;
    report += `\`\`\`markdown\n`;
    report += issueBody;
    report += `\n\`\`\`\n\n`;
    report += `</details>\n\n`;

    ticketNumber++;
  });

  return report;
}

/**
 * Maps impact level to Jira priority
 */
function getJiraPriority(impact: string): string {
  switch (impact.toLowerCase()) {
    case 'critical':
      return 'P1 - Critical';
    case 'serious':
      return 'P2 - High';
    case 'moderate':
      return 'P3 - Medium';
    case 'minor':
      return 'P4 - Low';
    default:
      return 'P3 - Medium';
  }
}

/**
 * Generates a GitHub issue body from accessibility violation data
 */
function generateGitHubIssueBody(
  violation: AxeResult,
  violationId: string,
  priority: string,
  impactLevel: string,
  themeMap: Map<string, { violation: AxeResult; record: ViolationRecord }[]>,
  suiteName: string
): string {
  let body = `## Accessibility Issue\n\n`;
  body += `**Priority**: ${priority}\n`;
  body += `**Impact**: ${impactLevel.toUpperCase()}\n`;
  body += `**Rule ID**: \`${violationId}\`\n`;
  body += `**WCAG**: ${violation.tags
    .filter((t) => t.startsWith('wcag'))
    .join(', ')}\n`;
  body += `**Test Suite**: ${suiteName}\n\n`;

  body += `### Description\n\n`;
  body += `${violation.description}\n\n`;

  body += `### Affected Themes\n\n`;
  themeMap.forEach((entries, theme) => {
    const totalElements = entries.reduce(
      (sum, e) => sum + e.violation.nodes.length,
      0
    );
    body += `- **${theme}**: ${totalElements} element(s) affected\n`;
  });
  body += `\n`;

  body += `### Technical Details\n\n`;
  themeMap.forEach((entries, theme) => {
    body += `**${theme} theme** - ${entries[0].violation.nodes.length} affected element(s)\n\n`;

    entries[0].violation.nodes.slice(0, 3).forEach((node: NodeResult, idx: number) => {
      body += `#### Element ${idx + 1}\n`;
      body += `- **Selector**: \`${node.target.join(' ')}\`\n`;
      body += `- **Issue**: ${node.failureSummary}\n`;
      if (node.html) {
        // Truncate long HTML for readability in issue
        const truncatedHtml = node.html.length > 200
          ? node.html.substring(0, 200) + '...'
          : node.html;
        body += `- **HTML**: \`${truncatedHtml}\`\n`;
      }
      body += `\n`;
    });

    if (entries[0].violation.nodes.length > 3) {
      body += `_... and ${entries[0].violation.nodes.length - 3} more element(s)_\n\n`;
    }
  });

  body += `### Acceptance Criteria\n\n`;
  body += `- [ ] All \`${violationId}\` violations are resolved\n`;
  body += `- [ ] Changes are verified in both light and dark themes\n`;
  body += `- [ ] Accessibility tests pass without violations\n`;
  body += `- [ ] Manual testing confirms proper functionality\n\n`;

  body += `### Resources\n\n`;
  body += `- [WCAG Documentation](${violation.helpUrl})\n`;
  body += `- [Axe Rule: ${violationId}](${violation.helpUrl})\n`;

  return body;
}

/**
 * Generates a GitHub issue creation URL with pre-filled title and body
 */
function generateGitHubIssueUrl(title: string, body: string): string {
  // Get repository info from environment or use a placeholder
  const repo = process.env.GITHUB_REPOSITORY || 'owner/repo';
  const baseUrl = `https://github.com/${repo}/issues/new`;

  // URL encode the title and body
  const params = new URLSearchParams({
    title: title,
    body: body,
    labels: 'accessibility,bug'
  });

  return `${baseUrl}?${params.toString()}`;
}

/**
 * Sets the theme and waits for it to be applied
 */
async function setTheme(page: Page, theme: 'light' | 'dark'): Promise<void> {
  await page.evaluate((t) => {
    localStorage.setItem('theme', t);
  }, theme);

  await page.reload();
  await page.waitForLoadState('domcontentloaded');

  // Wait for the theme class to be applied to the html element
  await page.locator(`html.${theme}`).waitFor({
    state: 'attached',
    timeout: THEME_TRANSITION_TIMEOUT,
  });

  // Verify theme is active
  const htmlClass = await page.locator('html').getAttribute('class');
  expect(htmlClass).toContain(theme);
}
